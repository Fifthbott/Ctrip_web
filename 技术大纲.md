# 游记网站后端服务技术大纲

## 1. 用户模块详细实现

### 1.1 用户认证与授权

#### 1.1.1 数据模型设计
项目使用Sequelize ORM定义了User模型，包含以下关键字段：
```js
// src/models/User.js
const User = sequelize.define('User', {
  user_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  username: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true
  },
  password_hash: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  nickname: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  avatar: {
    type: DataTypes.STRING(255),
    defaultValue: 'avatars/default_avatar.jpg'
  },
  role: {
    type: DataTypes.ENUM('user', 'admin', 'reviewer'),
    allowNull: false,
    defaultValue: 'user'
  },
  status: {
    type: DataTypes.ENUM('active', 'inactive', 'banned'),
    defaultValue: 'active'
  }
});
```

Sequelize模型通过钩子实现密码自动加密：
```js
// 模型钩子，在创建和更新用户前自动加密密码
hooks: {
  beforeCreate: async (user) => {
    if (user.password_hash) {
      user.password_hash = await bcrypt.hash(user.password_hash, 10);
    }
  },
  beforeUpdate: async (user) => {
    if (user.changed('password_hash')) {
      user.password_hash = await bcrypt.hash(user.password_hash, 10);
    }
  }
}
```

#### 1.1.2 用户认证流程
项目使用JWT实现无状态的用户认证，主要包括：

1. **用户注册流程**:
```js
// src/controllers/userController.js - register方法
exports.register = async (req, res, next) => {
  try {
    // 1. 验证用户名和昵称唯一性
    const existingUser = await User.findOne({ where: { username } });
    if (existingUser) {
      return next(new AppError('用户名已被使用', 400));
    }
    
    // 2. 创建用户（密码通过模型钩子加密）
    const user = await User.create({
      username,
      password_hash: password,
      nickname,
      avatar,
      role: 'user',
      status: 'active'
    });
    
    // 3. 生成JWT令牌
    const token = generateToken({
      user_id: user.user_id,
      username: user.username,
      role: user.role
    });
    
    // 4. 返回用户信息和令牌
    res.status(201).json({
      status: 'success',
      message: '注册成功',
      data: { user: {...}, token }
    });
  } catch (error) {
    next(error);
  }
};
```

2. **用户登录流程**:
```js
// src/controllers/userController.js - login方法
exports.login = async (req, res, next) => {
  try {
    const { username, password } = req.body;
    
    // 1. 查找用户
    const user = await User.findOne({ where: { username } });
    if (!user) {
      return next(new AppError('用户名或密码不正确', 401));
    }
    
    // 2. 验证密码
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      return next(new AppError('用户名或密码不正确', 401));
    }
    
    // 3. 检查用户状态
    if (user.status !== 'active') {
      return next(new AppError('账户已被禁用或停用', 403));
    }
    
    // 4. 生成JWT令牌
    const token = generateToken({
      user_id: user.user_id,
      username: user.username,
      role: user.role
    });
    
    // 5. 返回用户信息和令牌
    res.status(200).json({
      status: 'success',
      message: '登录成功',
      data: { user: {...}, token }
    });
  } catch (error) {
    next(error);
  }
};
```

3. **JWT生成和验证**:
```js
// src/utils/jwt.js
// 生成JWT令牌
const generateToken = (payload) => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
};

// 验证JWT令牌
const verifyToken = (token) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    console.error('JWT验证失败:', error.message);
    return null;
  }
};
```

#### 1.1.3 认证中间件
项目定义了几种认证中间件来保护API路由：

1. **强制认证中间件**:
```js
// src/middleware/auth.js - authenticate方法
const authenticate = async (req, res, next) => {
  try {
    // 1. 获取并验证Token
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.error('未提供授权令牌', 401, 'AUTH_TOKEN_MISSING');
    }
    
    const token = authHeader.split(' ')[1];
    const decoded = verifyToken(token);
    if (!decoded) {
      return res.error('授权令牌无效或已过期', 401, 'INVALID_TOKEN');
    }
    
    // 2. 查找用户并验证状态
    const user = await User.findByPk(decoded.user_id, {
      attributes: ['user_id', 'username', 'nickname', 'avatar', 'role', 'status']
    });
    
    if (!user || user.status !== 'active') {
      return res.error('用户不存在或已禁用', 401);
    }
    
    // 3. 将用户信息附加到请求对象
    req.user = user;
    next();
  } catch (err) {
    return res.error('认证失败', 401, 'AUTH_FAILED');
  }
};
```

2. **可选认证中间件**:
```js
// 如果请求包含有效的JWT令牌，则附加用户信息，否则继续处理
const optionalAuthenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return next(); // 无token继续
    }
    
    // 验证token并查找用户
    // 如果有效，附加用户信息；如果无效，继续处理
    // ...
  } catch (err) {
    next();
  }
};
```

3. **角色授权中间件**:
```js
// 检查用户是否具有特定角色
const authorize = (roles = []) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.error('需要先进行身份验证', 401);
    }
    
    if (roles.length && !roles.includes(req.user.role)) {
      return res.error('没有访问权限', 403, 'INSUFFICIENT_PERMISSIONS');
    }
    
    next();
  };
};
```

#### 1.1.4 路由权限管理
项目通过Express路由系统实现API的权限控制：

```js
// src/routes/userRoutes.js
const router = express.Router();

// 公开路由（无需认证）
router.post('/register', userValidators.register, userController.register);
router.post('/login', userValidators.login, userController.login);

// 需要身份验证的路由
router.use(authenticate); // 应用认证中间件到以下所有路由

// 用户路由 - 所有认证用户可访问
router.get('/me', userController.getMe);
router.put('/me', userValidators.updateUser, userController.updateMe);

// 管理员路由 - 只有管理员角色可访问
router.get('/', authorize(['admin']), userController.getAllUsers);
```

### 1.2 用户头像上传

#### 1.2.1 文件上传配置
项目使用Multer处理文件上传，专门为头像配置了存储和处理策略：

```js
// src/utils/fileUpload.js
// 头像存储配置
const avatarStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadDir = path.join(process.cwd(), UPLOAD_PATH, 'avatars');
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueFileName = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFileName);
  }
});

// 头像上传配置
const uploadAvatar = multer({
  storage: avatarStorage,
  limits: { fileSize: 2 * 1024 * 1024 }, // 头像限制2MB
  fileFilter: imageFilter
});
```

#### 1.2.2 头像上传处理中间件
针对头像上传，项目封装了专用中间件：

```js
// 头像上传中间件
const handleAvatarUpload = (req, res, next) => {
  uploadAvatar.single('avatar')(req, res, (err) => {
    if (err) {
      return next(err);
    }
    next();
  });
};

// Multer错误处理中间件
const handleMulterError = (err, req, res, next) => {
  if (err) {
    // 清理可能已上传的文件
    if (req.file) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (fileErr) {
        console.error('清理文件失败:', fileErr);
      }
    }
    
    // 根据错误类型返回友好的错误消息
    if (err instanceof multer.MulterError) {
      let message = '文件上传错误';
      switch (err.code) {
        case 'LIMIT_FILE_SIZE':
          message = '文件大小超出限制';
          break;
        // ...其他错误类型处理
      }
      return res.error(message, 400, err.code);
    } else {
      return res.error(`文件上传失败: ${err.message}`, 500);
    }
  }
  next();
};
```

#### 1.2.3 头像更新控制器
头像上传成功后，由控制器处理头像更新：

```js
// src/controllers/userController.js - updateAvatar方法
exports.updateAvatar = async (req, res, next) => {
  try {
    // 1. 检查是否有文件上传
    if (!req.file) {
      return next(new AppError('未上传头像文件', 400));
    }
    
    // 2. 获取用户信息
    const userId = req.user ? req.user.user_id : req.body.user_id;
    if (!userId) {
      return next(new AppError('未提供用户ID', 400));
    }
    
    // 3. 查找用户并更新头像
    const user = await User.findByPk(userId);
    if (!user) {
      return next(new AppError('用户不存在', 404));
    }
    
    // 4. 生成头像URL并更新用户记录
    const avatarUrl = getFileUrl(req.file, 'avatar');
    user.avatar = avatarUrl;
    await user.save();
    
    // 5. 返回更新后的用户信息
    res.status(200).json({
      status: 'success',
      message: '头像更新成功',
      data: {
        avatar: avatarUrl
      }
    });
  } catch (error) {
    next(error);
  }
};
```

### 1.3 用户信息管理

#### 1.3.1 获取用户信息
已认证用户可以获取自己的信息：

```js
// src/controllers/userController.js - getMe方法
exports.getMe = async (req, res) => {
  // 直接返回认证中间件附加的用户信息
  res.status(200).json({
    status: 'success',
    data: {
      user: req.user
    }
  });
};
```

#### 1.3.2 更新用户信息
用户可以更新自己的昵称和密码：

```js
// src/controllers/userController.js - updateMe方法
exports.updateMe = async (req, res, next) => {
  try {
    const { nickname, password } = req.body;
    const userId = req.user.user_id;
    
    // 1. 查找用户
    const user = await User.findByPk(userId);
    
    // 2. 如果更新昵称，检查是否已被使用
    if (nickname && nickname !== user.nickname) {
      const existingNickname = await User.findOne({ 
        where: { 
          nickname,
          user_id: { [require('sequelize').Op.ne]: userId } // 排除当前用户
        } 
      });
      
      if (existingNickname) {
        return next(new AppError('昵称已被使用', 400));
      }
    }
    
    // 3. 更新用户信息
    if (nickname) user.nickname = nickname;
    if (password) user.password_hash = password; // 密码会通过模型钩子自动加密
    
    await user.save();
    
    // 4. 返回更新后的用户信息
    res.status(200).json({
      status: 'success',
      message: '用户信息更新成功',
      data: { user: {...} }
    });
  } catch (error) {
    next(error);
  }
};
```

## 2. 数据验证与错误处理

### 2.1 请求数据验证
项目使用自定义验证中间件对用户输入进行验证：

```js
// src/middleware/validators.js (示例)
const userValidators = {
  register: [
    body('username')
      .trim()
      .isLength({ min: 3, max: 30 })
      .withMessage('用户名长度应在3-30个字符之间')
      .matches(/^[a-zA-Z0-9_]+$/)
      .withMessage('用户名只能包含字母、数字和下划线'),
    body('password')
      .isLength({ min: 6 })
      .withMessage('密码至少需要6个字符'),
    body('nickname')
      .trim()
      .isLength({ min: 2, max: 30 })
      .withMessage('昵称长度应在2-30个字符之间'),
    // 验证错误处理
    validationErrorHandler
  ],
  // 其他验证规则...
};
```

### 2.2 统一错误处理
项目实现了统一的错误处理机制：

```js
// src/middleware/error.js
// 自定义错误类
class AppError extends Error {
  constructor(message, statusCode, errorCode) {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode || 'ERROR';
    this.isOperational = true;
  }
}

// 全局错误处理中间件
const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;
  
  // 处理不同类型的错误
  // ...
  
  // 返回统一格式的错误响应
  res.status(error.statusCode || 500).json({
    status: 'error',
    code: error.errorCode || 'SERVER_ERROR',
    message: error.message || '服务器内部错误'
  });
};
```

## 3. 安全最佳实践

### 3.1 密码安全
- 使用bcrypt进行密码哈希，防止明文存储
- 密码比较使用安全的时间恒定比较方法，防止时序攻击

### 3.2 JWT安全
- 令牌有效期配置合理，默认为7天
- 密钥通过环境变量注入，而非硬编码

### 3.3 输入验证
- 对所有用户输入进行严格验证
- 实现特定的文件类型和大小限制

### 3.4 认证与授权分离
- 先验证用户身份（认证）
- 再检查用户权限（授权）
- 针对不同角色实现细粒度的访问控制 